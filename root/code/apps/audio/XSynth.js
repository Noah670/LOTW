/*

Mainly for tuning oscillators at various levels of granularity.

Here, the top 3 knobs are "+" knobs and the bottom 3 are "-" knobs.
The scaling factors for each column are the same (eg, knobs 1 and 5 are in the same
column).

osc_detune.value = GRANULARITY*(M1*KV[1]+M2*KV[2]+M3*KV[3]-(M1*KV[5]+M2*KV[6]+M3*KV[7]));

Want to keep track of the current state of each knob as it is changed. 

Synchronization issues:

When doing nothing onwinblur, if the knobs do not match onwinfocus, we need to
alert to put them back.

Or onwinblur, set the frequency to the current effective frequency (frequency + detune), 
and then onwinblur, do not allow knob updates until all knobs are back at 0.

Also, we can do a keydown event in order to fold the detune into the frequency and
then require that they are all back to 0 before allowing updates again.




This is the central location for interfacing between Synth objects and the real
world of hardware controllers. There can be LOTW system environment variables
which define models of midi/game/USB controllers, etc., and this app can load
have the knowledge of the physical hardware layout, how the mode/meta toggling
controls work, and what kinds of events are generated by the various buttons,
keys and knobs within the various modes.



Want to do hotplugging of midi, gamepad, WebUSB(!) and attach the incoming
events to the parameters. Perhaps we can define nodes in '.synth' files with
'.xsynth' configuration files that will be read and implemented here. Either as
as parameter in the constructor or do something like:

Osc o;
o.xsynth="/path/to/file.xsynth"

Of course, the nodes can be arbitrarily complex abstractions of, e.g. musical instruments,
and the configuration files can likewise be arbitrarily complex.

*/
export const app = function (arg) {
const {Core, Main, NS}=arg;
const win = Main.top;
const{api:capi,KC,kc,log,cwarn,cerr,globals,Desk}=Core;

const KNOBVALS=(globals.AppVars["Synth-KNOBVALS"]||[0,0,0,0,0,0,0,0,0]);
const KV = KNOBVALS;

//const log=(...args)=>console.log(...args);
//const wrn=(...args)=>console.warn(...args);
//const cwarn=wrn;
//const err=(...args)=>console.error(...args);
//const cerr=err;
const wrn = cwarn;
const err = cerr;
let n;

//const n = arg.NODE || Core.get_appvar(Main.top, "NODE");//Node

const OSC_DETUNE_FAC = 0.1;

let volup;
let voldn;
let togmute;
let setvol;
let type;
let name;
let t;
let base_det;
let osc_detune;

const init=()=>{//«

	volup = n._winobj.volume_up;
	voldn = n._winobj.volume_dn;
	togmute = n._winobj.toggle_mute;
	setvol = n._winobj.set_volume;

	type = n._type;
	name = n._name;

	if (type=="Osc") {
		t = 1;
		base_det = n.frequency.value/OSC_DETUNE_FAC;
	cwarn("BASEDET", base_det);
		osc_detune = n.detune;
	}

	Main.innerHTML = type;
	Main.bgcol="#000";
	Main.tcol="#AAA";
	n._window = win;
	win.title = `${type}\x20(${name})`;

};//»


this.onkill = ()=>{

	Core.set_appvar(Main.top, "NODE", n);//Node
	delete n._window;

};

this.onkeydown=(e,s)=>{
log(s);
};

this.onmidiknob=(e)=>{
	let num = e.knob;
	let val = e.val;
	KNOBVALS[num] = val;
//    let knob = KNOBS[num+""];
//    if (knob) knob(val);
//log(e);
if (num==4){
setvol(val/127);
return;
}
else if (num==8) return;

if (t==1){//Osc
/*
let d = base_det;
if (num==1)d*=1;
else if (num==2)d*=10;
else if (num==3)d*=100;
else if (num==5)d*=-1;
else if (num==6)d*=-10;
else if (num==7)d*=-100;
else return;
*/

//log(d*(KV[1]+5*KV[2]+25*KV[3]))
//osc_detune.value = base_det*(KV[1]+5*KV[2]+25*KV[3]);
//,KV[5],5*KV[6],25*KV[7]);

osc_detune.value = base_det*(KV[1]+5*KV[2]+25*KV[3]-(KV[5]+5*KV[6]+25*KV[7]));


}

}
this.onappinit=(arg)=>{

n = arg.NODE || Core.get_appvar(Main.top, "NODE");//Node
init();
//log(n);

};
this.onmidikeydown=e=>{
//    let f = MIDIKEYDOWNS[e.key+""];
//    f&&f();
log(e);
let k = e.key;
if (k==44)return togmute();

if (t==1){
	if (k==48) n.type="sine";
	else if (k==50) n.type="triangle";
	else if (k==52) n.type="square";
	else if (k==53) n.type="sawtooth";
}
};
this.onmidikeyup=e=>{
//    let f = MIDIKEYUPS[e.key+""];
//    f&&f();
log(e);
};

}


